# Scripts-of-Manuscripts-prepared-at-Penn
### Scripts for Multidimensional scaling plot based on genome-wide identity-by-state pairwise distances between cases and controls of late-onset cataract in American cocker spaniel dogs ###

================================================================================================================================================

# Perform MDS in plink using commands --cluster and --mds-plot 10 and extract mds plot

df <- read.table("covar_mds.txt",header=T,as.is=T)
head(df);dim(df)

Pheno <- read.table("Late_Onset_ACS_Dec19.1.fam",header=F,as.is=T)
head(Pheno)
colnames(Pheno) <- c("FID","IID","Zero1","Zero2","Sex","Phenotype")

# convert first column to row names
M1 <- merge(df,Pheno,by="IID")
rownames(M1) <- M1[,1]
M1[,1] <- NULL
head(M1);dim(M1) # 58 3
row.names(M1)
M1$Condition <- ifelse(M1$Phenotype==2, "Cases", "Controls")

tiff("mds.Jan5.tiff", width = 10, height = 6, units = 'in', res = 300)
plot(M1$C1,M1$C2, pch=19, cex=.5, col=factor(M1$Phenotype), xlab="MDS 1", ylab="MDS 2")
legend("topright",legend=levels(factor(M1$Condition)), pch=19,col=factor(levels(factor(M1$Phenotype))))
text(M1, pch=19, cex=0.3, pos = 3, row.names(M1))
dev.off()


===================================================================================================================================================

########## Codes for running Binary case-control GWAS in Plink ################################################################################# 


# # Investigate missingness per individual and per SNP 

plink --bfile VB_Dec21 --allow-extra-chr --chr-set 38 --missing

# Delete SNPs with missingness >0.2

plink --bfile VB_Dec21 --allow-extra-chr --chr-set 38 --geno 0.2 --make-bed --out VB_Dec21.1

# Delete individuals with missingness >0.2

plink --bfile VB_Dec21.1 --allow-extra-chr --chr-set 38 --mind 0.2 --make-bed --out VB_Dec21.2

# Delete SNPs with missingness >0.05

plink --bfile VB_Dec21.2 --allow-extra-chr --chr-set 38 --geno 0.05 --make-bed --out VB_Dec21.3

# Delete individuals with missingness >0.05

plink --bfile VB_Dec21.3 --allow-extra-chr --chr-set 38 --mind 0.05 --make-bed --out VB_Dec21.4

# Generate a bfile with autosomal SNPs only and delete SNPs with a low minor allele frequency (MAF).

awk '{ if ($1 >= 1 && $1 <= 38) print $2 }' VB_Dec21.4.bim > snp_1_38.txt


# Generate a bfile with autosomal SNPs only and delete SNPs with a low minor allele frequency (MAF).

plink --bfile VB_Dec21.4 --allow-extra-chr --chr-set 38 --extract snp_1_38.txt --make-bed --out VB_Dec21.5


# Generate a plot of the MAF distribution
plink --bfile VB_Dec21.5 --allow-extra-chr --chr-set 38 --freq --out MAF_check


# Remove SNPs with a low MAF frequency.
plink --bfile VB_Dec21.5 --allow-extra-chr --chr-set 38 --maf 0.01 --make-bed --out VB_Dec21.6

# Check the distribution of HWE p-values of all SNPs.
plink --bfile VB_Dec21.6 --allow-extra-chr --chr-set 38 --hardy 

# Selecting SNPs with HWE p-value below 0.00001, required for one of the two plot generated by the next Rscript, allows to zoom in on strongly deviating SNPs. 
awk '{ if ($9 <0.00001) print $0 }' plink.hwe>plinkzoomhwe.hwe

#use a stringent HWE threshold for controls for HWE 
plink --bfile VB_Dec21.6 --hwe 1e-6 --allow-extra-chr --chr-set 38 --make-bed --out VB_Dec21.7

# use a stringent HWE threshold for cases for HWE
plink --bfile VB_Dec21.7 --hwe 1e-10 --hwe-all  --allow-extra-chr --chr-set 38 --make-bed --out VB_Dec21.8


plink --bfile VB_Dec21.8 --allow-extra-chr --chr-set 38 --indep-pairwise 50 5 0.2 --out indepSNP


# heterozygosity
plink --bfile VB_Dec21.8  --allow-extra-chr --chr-set 38 --extract indepSNP.prune.in --het --out R_check


# Relatedness
plink --bfile VB_Dec21.8 --allow-extra-chr --chr-set 38 --extract indepSNP.prune.in --genome --min 0.2 --out pihat_min0.2

## Perform MDS using a set of pruned SNPs

plink --bfile VB_Dec21.8 --allow-extra-chr --chr-set 38 --extract indepSNP.prune.in --genome --out MDS_merge2

plink --bfile VB_Dec21.8 --read-genome MDS_merge2.genome --allow-extra-chr --chr-set 38 --cluster --mds-plot 10 --out MDS_merge2

awk '{print$1, $2, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13}' MDS_merge2.mds > covar_mds.txt


## Perform Genome-wide association study

 plink --bfile VB_Dec21.8 --allow-extra-chr --chr-set 38 --assoc --adjust --out NoCov_adjusted_assoc_results
 plink --bfile VB_Dec21.8 --allow-extra-chr --chr-set 38 --covar covar_mds.txt --logistic --hide-covar --out PCs_logistics_results
 awk '!/'NA'/' PCs_logistics_results.assoc.logistic > PCs_logistic_results.assoc_2.logistic
 plink --bfile VB_Dec21.8 --allow-extra-chr --chr-set 38 --assoc --out assoc_results

 ## PERMUTATION GWAS
  plink --bfile VB_Dec21.8 --allow-extra-chr --chr-set 38 --aperm 5 1000  --model mperm=1000  --mperm-save-all --seed 10835
 plink --bfile VB_Dec21.8 --chr-set 38 --assoc --aperm 10 1000000 0.0001 0.01 5 0.001 --out NEWPERMASSOC

 ===================================================================================================================================================

########## Codes for running Haplotype GWAS in Plink #################################################################################


1) Phasing the chromosome using Beagle (v 5.0)

for((i=1;i<=39;i++))

do

echo "#!/bin/bash" > ${i}.plink.sh
echo "#BSUB -J ${i}.bamgaK"  >> ${i}.plink.sh
echo "#BSUB -o ${i}.bamgaK.o" >> ${i}.plink.sh
echo "#BSUB -e ${i}.bamgaK.e" >> ${i}.plink.sh
echo "#BSUB -n 1"  >> ${i}.plink.sh
echo "#BSUB -M 50000"  >> ${i}.plink.sh
echo "if [ -f /etc/profile.d/modules.sh ]; then"   >> ${i}.plink.sh
echo "source /etc/profile.d/modules.sh"   >> ${i}.plink.sh
echo "fi "   >> ${i}.plink.sh
echo "module load plink-1.90b3b" >> ${i}.plink.sh
echo "module load java/openjdk-1.8.0" >> ${i}.plink.sh
echo "module load bcftools/1.11" >> ${i}.plink.sh

# Create VCF files per chromosomes from  map and ped files

./plink2 --pedmap Final_ACS_DEDUP_Nov9 --recode vcf --allow-extra-chr --chr-set 38 --snps-only just-acgt  --out filter_data_${i} --chr ${i}

# Imputation and Phasing with Beagle

java -Xmx8g -jar /home/sigdel/PROGRAMS/beagle.jar gt=filter_data_${i}.vcf out=Phased_${i}

gunzip Phased_${i}.vcf.gz

# Converting phased genotypes to haplotypes using plink2

./plink2 --vcf Phased_${i}.vcf --dog --export haps --out chr_${i}


# Extract Markers file

awk '{print $1,$2,$3,$4,$5}' chr_${i}.haps > markers_${i}

# Extract Phase file

cut -f6- -d" " chr_${i}.haps > Phase_${i}

done


###############################################################
# Importing Phased data in GHap package #
# Manipulate the output of beagle
# Beagle took the VCF file and outputs phased haplotypes file
# create .samples file, .markers file and .phase file using awk
###############################################################

2)	Construction of haplotype blocks through GHap (v 3.0.0) package in R

library(GHap)

ghap.compress(samples.file = "Phenotype_ACS",
              markers.file = "CombinedMarkers_1_38",
              phase.file = "CombinedPhase_1_38.phase",
              out.file = "CombinedNov10")

# Loading the Haplotype object
Phase_all <- ghap.loadphase(samples.file = "Phenotype_ACS",
                            markers.file = "CombinedMarkers_1_38",
                            phaseb.file = "CombinedNov10.phaseb")

# allele frequency control
freq <- ghap.freq(Phase_all, type = 'maf')
mkr <- names(freq)[which(freq > 0.05)]
length(mkr) 

pure1 <- unique(Phase_all$id[which(Phase_all$pop == "ACS")])
length(pure1) 

Phase_all <- ghap.subset(object = Phase_all, ids =pure1, variants = mkr)
names(Phase_all);class(Phase_all)


blocks.5kb <- ghap.blockgen(Phase_all, windowsize = 5, slide = 5, unit = "kbp")
write.table(blocks.50kb,file="ACS_blocks.50kb_all",row.names=F,col.names=T,append=F,quote=F,sep=" ")

#########################################################################################################


# Give a marker file and a phase file and 
# gets haploalleles, haplogenotypes and haplosamples
ghap.haplotyping(object = Phase_all, blocks = blocks.5kb,
                 outfile = "ACS_haps_5kb_geno", binary = TRUE)

# Load haplotype genotypes using prefix
haplo <- ghap.loadhaplo("ACS_haps_5kb_geno")

# Convert to plink
ghap.hap2plink(haplo, outfile = "ACS_haps_5kb_geno")


##############################################################################################################

# Use GEMMA for creating Genomic Relationship matrix
./gemma -bfile ACS_haps_5kb_geno -gk 1 -miss 0.05 -maf 0.05 -r2 0.9999 -hwe 0.00000001 -o GRM  

# Use GEMMA for association study
./gemma -bfile ACS_haps_5kb_geno -k output/GRM.cXX.txt -c covF -lmm 4 -o hap


===================================================================================================================================================

########## Codes for running Homozygosity Mapping in Plink #################################################################################


plink --tfile Cirneco_Part --dog --homozyg group --homozyg-density 50 --homozyg-gap 500 --homozyg-kb 50 --homozyg-match 1 --homozyg-snp 50 --homozyg-window-het 1 --homozyg-window-missing 1 --homozyg-window-snp 50 --homozyg-window-threshold 0.05 --out Final  


##########################################################
# Finding the homozygous region using Rscript
##########################################################

# filter at the level of phenotype and group
# Different GRP is different haplotypes
# In the same group to be considered a homozygous region, all cases excluding controls must share that regions 
# for every group (S..) if just one case completely overlaps with the control, we need to ignore that group.

setwd("/Users/anilsigdel/Documents/Homozygosity_Mapping")


library(dplyr)

# reading the file
Final_hom_overlap <- read.table("Final.hom.overlap",header=T,as.is=T)
head(Final_hom_overlap);dim(Final_hom_overlap) 
head(Final_hom_overlap);dim(Final_hom_overlap) # 2333 13
length(unique(Final_hom_overlap$POOL)) # 515

# Split the final homozygosity overlap based on cases:controls
x <- split(Final_hom_overlap,Final_hom_overlap$PHE )
names(x)

# only take those splits with all 2 cases as all 2 cases must overlap from
# a pool to be considered homozygous region!
x[[6]];x[[7]];x[[8]];

# 2:0 cases
df_2_0 <- as.data.frame(x[[6]]);df_2_0; dim(df_2_0)
df_2_0 <- df_2_0[df_2_0$FID=="CON",] # S373, S402, S425

# taking all samples from POOL 
df_2_0 <- Final_hom_overlap[Final_hom_overlap$POOL %in% df_2_0$POOL,] 
head(df_2_0);dim(df_2_0) # 504 13
unique(df_2_0$GRP) # 1, 1*, NA   "2*"


# removing the duplicated row in a data-frame
df_2_0 <- df_2_0 %>% distinct() 
df_2_0 <- df_2_0[df_2_0$FID==1,]
dim(df_2_0) # 252 13

# removing the duplicated row in a data-frame
df_2_0 %>%
  semi_join(df_2_0 %>%
              group_by(POOL,PHE) %>%
              filter(row_number()>1), 
            by = c("BP1", "BP2"))

df_2_0 <- df_2_0[,c(1,4,5,8,9,10)]
df_2_0  <- df_2_0 %>% distinct()  
dim(df_2_0) # 187 6
write.table(df_2_0,file="df_2_0.txt",row.names=T,col.names=T,append=F,sep=" ")

####### 2 cases and 1 control #############################################
df_2_1 <- as.data.frame(x[[7]]);df_2_1; dim(df_2_1) # 174 13
df_2_1 <- Final_hom_overlap[Final_hom_overlap$POOL %in% df_2_1$POOL,] 
df_2_1 <- df_2_1[df_2_1$FID==1,]
dim(df_2_1) # 261 13


# Again filtering at the level of gr/haplotypes

x1 <- split(df_2_1,df_2_1$GRP)
x1[[1]];x1[[2]];x1[[3]];x1[[4]]
dim(x1[[1]]) # 161 13
dim(x1[[2]]) # 87 13
dim(x1[[3]]) # 13 13


# Taking only 1 haplotypes
df_4_1_Gr1 <- rbind(x1[[1]],x1[[2]])
dim(df_4_1_Gr1) # 26 13
df_4_1_Gr1 <- df_4_1_Gr1 %>% distinct() 
dim(df_4_1_Gr1) # 26 13
unique(df_4_1_Gr1$POOL) # 
# "S280" "S297" "S298" "S315" "S316" "S323"

df_4_1_Gr2 <- x1[[3]];x1[[4]] # All controls phenotype in different haplos

# removing the duplicated row in a data-frame
df_4_1 <- df_4_1_Gr1 %>%
  semi_join(df_4_1_Gr1 %>%
              group_by(POOL,PHE) %>%
              filter(row_number()>1), 
            by = c("BP1", "BP2"))
unique(df_4_1$POOL)

# "S280" "S297" "S298" "S315" "S316" "S323"
#  Removing S315 and S316 that has the case completely overlaps with the control
re <- c("S315","S316")
df_4_1 <- subset(df_4_1,POOL!="S315" & POOL!="S316")
dim(df_4_1) # 15 13

Finalpool <- unique(df_4_1$POOL);Finalpool
# S280 S297 S298 S323

Final <- df_4_1_Gr1[df_4_1_Gr1$POOL %in% Finalpool,]
dim(Final)

Final <- Final[!duplicated(Final[ , c("POOL", "PHE","BP1","BP2")]), ]
write.table(Final,file="df_4_1.txt",row.names=T,col.names=T,append=F,sep=" ")
